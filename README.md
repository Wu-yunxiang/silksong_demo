描述流程：
每过一段时间，刷新scene
每次刷新前处理键盘事件,更新各种gameobject
刷新就是根据各种gameobject的内部状态进行刷新
刷新完之后进行判定，修改状态，渲染

gameengine执行刷新操作while（true）{xxx}
xxx:scene.update
update:handleinput->for each obj update -> check ->渲染
我的scene只是用来打包整个画面的对象，renderer负责render scene先不考虑render文本
gameengine初始化各种配置，比如inputmanager,renderer,scene等
gamelogic 处理input，对scene进行update和check（创建特效对象等）
update是调用每个obj的update,check是针对各种交互事件和边界检查的
character的基础字段包括 存活状态，mode持续时间，是否处于免疫状态，免疫时间，拥有特效列表（owner），速度加速度，位置等
一个character有状态组件（血量血条两个object），有技能组件(一个object列表)。有基本信息，和mode  渲染的时候主体根据mode（分类渲染），组件要渲染

character主体包含了头发，脸，身体，手，腿，脚这几部分，分开管理，但又紧密组合成了character主体部分,用list<身体部件类型>来保存，身体部件类型新创建一个文件夹，分为基类和这些部件，基类声明map<部件状态，相对于character的baseposition的像素分布表格表格包含颜色信息>，每个具体类硬编码map（相当于手工设计不同状态下的形象然后把形象映射到各个部位，每个部位在不同状态下形象不同，但是是由事件触发的，各个部件不同状态下位置的协同是由上层保证的，先不用管）。请你根据我的要求实现框架但不要代码实现

不管创建多少个bodypart，同一种part硬编码出来的stateconfigs是固定的，现在的逻辑不正确，应该用 把statecomfigs设置为static?各个part 的构造方法私有，但是可以

k跳跃，第一次跳起来未落地再k触发二段跳，w上，s下，a左，d右，l冲刺，短摁q技能，j攻击，长摁q回血
w+j  s+j 分别是上批和下批
对于processinput来说，我认为需要

给characterMode增加攻击这一模式修改与之相关的文件，其它都不变
先取出events里决定人物朝向的事件更改，再取出决定charactermode的事件更改，再取出与特效相关的事件进行对应逻辑。只改processinput方法

每一帧之后检查逻辑：给skill,character,tarrain对象添加一个判定范围，矩形
对于character检查和这几种对象是否在判定范围上相交，如果相交触发逻辑（逻辑具体怎么样不要写）

请你帮我实现handlecollisions和boundarychecks的伪代码,如果你觉得characterbehaviorevent和charactermode的设置有些不妥或者冗余确实，并请修改与这些相关联的地方，其它都不要改

更行逻辑
character 在render的时候，

待定：onground判断，长按回血逻辑







先把rect类修改为（左上坐标和长宽）
涉及的所有图片大小已经统一
resource里我会存放人物的各个行为的系列图片，技能的系列图片，静态背景，静态地板，静态陷阱
对于背景，直接填充scene放在最底图层
对于地板和陷阱，只存储判定框
对于技能系列，每张图片存储基准坐标和相对于基准坐标的判定框（rect）,速度加速度等都是运用于基准坐标的逻辑
对于人物中的某个行为系列，每张图片存储基准坐标和相对于基准坐标的判定框（rect）
距离单位始终是像素
baseposition存储的是gameobj基准所在的像素
渲染的时候，如果角色正在某个baseposiotion上，根据角色状态找到正要渲染的图片，找到该图片的基准（x,y）和baseposition(a,b) 得出 导入图片的位置(左上角)坐标（a-x,b-y）调用的系统画图函数是图片左上角在屏幕中的像素位置

手动编码的时候，确定了（x,y）,确定左下角判定边界，记录相对于（x,y）的增量；确定右上角判定边界，记录相对于（x,y）的增量。存rect(第一个增量，第二个的增量x减掉第一个的增量x,第一个的增量y减掉第二个的增量y),判定框（baseposition+增量，后两个）

对于每张图片硬编码持续的帧数，图片存储在resource目录下，character的子文件夹和characater状态名字一一对应，里面的图片放在文件夹里1，2，3...例如文件夹1存储1.png和1.txt？描述图片的所有硬编码。程序在预处理（配置）阶段可以把硬编码读取到本地。

让我们重新梳理gamelogic每轮的逻辑：
参数为间隔的时间t和游戏场景
inputmanager记录按下的按键的持续时间，记录有哪些键按下，记录这一帧按下的键
首先处理时间t内的键盘事件，
对于摁住的按键，观察hold时间，如果大于临界值进入回血逻辑。如果小于临界值继续观察，如果在临界值之前松开，触发短按逻辑，否则进入回血逻辑。如果在回血结束之前被打断或者松开，则失效。

角色分为受击判定框和攻击判定框
龙的受击判定框和攻击判定框相同，只需要一个统一的判定框
角色的攻击判定框且在下批过程中与龙的判定框交集，则触发弹起等逻辑


空中分为上升和下落，如果上升，调用图片3，如果下落，调用图片4

攻击，起跳，走路互不冲突，渲染优先级：攻击>起跳>走路 渲染的时候特别判断

JUMP隐形存在，只有落地能结束jump
渲染的时候要jump是最高优先级的时候才渲染，根据isfalling和高度决定写哪一帧

每张图片都有一个基准位置，基准位置下方的贴图有所不同。如果速度为0，比如说是攻击，那么原来站着的脚可能悬空了，所以相当于每一帧都依靠checkboundary进行修正



